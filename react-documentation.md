//
RENDERING:
რეაქტი როცა ჩაიტვირთება აპლიკაცია წაიკითხავს მთლიან კომპონენტს, როცა მოხდება რაიმე ელემენტის ცვლილება, ანუ შეიცვლება state,
რეაქტი გადაირბენს წაიკითხავს მთლიან კომპონენტს
მაგრამ rerenders გაუკეთებს მხოლოდ იმ ელემენტს jsx'ში რომელშიც მოხდა ცვლილება.
სტეიტის და პროპსის ცვლილება იწვევს კომპონენტის re render'ს.
//

//
PROPS:
კომპონენტის შექმნის დროს პარამეტრად შეგიძლია ჩააწოდო props რომელიც არის ობიექტი და აღწერისას შეგიძლია ყველა საჭირო key ები გაუწერო
შემდეგ კი მშობელ კომპონენტში ამ კომპონენტის გამოძახებისას, value'ს მიაწვდი.
ასევე შეგიძლია, დესტრუქტურიზაციით გაუწერო პროპსები მაგალითად: function Stock({product,quantity});
//

//
STATE:
const [count, setCount] = useState(0);
ამ შემთხვევაში გვაქვს ცვლადი count თავისი ფუნქციით, რომლის მეშვეობითაც შეგვიძლია შევუცვალოთ მნიშვნელობა count'ს,
() << აღწერისას ამ ფრჩხილებში მინიჭებული მნიშვნელობა არის საწყისი მნიშვნელობა.
//

//
STATE LIFTING:
როცა ვქმნით კომპონენტს მაგალითად ბათონს და გვინდა რომ ამ ბათონის დაჭერისას მეზობელ კომპონენტში რომელიც, პირობითად
ტაიმერი ავიღოთ, ვზარდოთ დრო, ხდება შემდეგ ნაირად: Button კომპონენტს ვქმნით ვაწვდით პროპსად რომ მიიღოს ფუნქცია, პირობითად
onTimeUp, გავუწერთ onClick={onTimeUp}, ბათონ კომპონენტის გამოძახებისას მშობელში გავწერთ ლოგიკას, რომ დროის მომატება მოხდეს, ამ ფუნქიას მივაწვდით
პროპსად // Button onTimeUp={ლოგიკა} //
//

//
USE EFFECT:
useEffect(( => {
console.log('use effect')
}))
როცა კონტენტი დარენდერდება ან რე რენდერი მოხდება, use effect ში გადაწოდებული კოდი გაეშვება ერთჯერადად,
useEffect'ში არ შეიძლება setState'ის ჩაწერა რადგან იწვევს ჩაციკვლას, ვინაიდან useEffect ეშვება რენდერზე/რერენდერზე და state ცვლილება იწვევს კომპონენტის
რერენდერს.

useEffect(( => {
console.log('use effect')
}), []);
თუ დავწერთ ესე, ამ შემთხვევაში useEffect გაეშვება mount ზე მხოლოდ და არა რერენდერზე.
//

useEffect(( => {
console.log('use effect')
}), [აქ თუ ჩავწერთ states'ს ან prop'ს]);
როცა მოხდება სთეითის ან პროპსის ცვლილება useEffect'ის ტანში არსებული კოდი გაეშვება.
